open import Level using (Level)

module Parser (l : Level) where

open import Agda.Builtin.Nat renaming (Nat to ‚Ñï)
open import Agda.Builtin.Maybe

open import Level.Bounded renaming (_√ó_ to _√ób_; List to Listb) hiding (Maybe; Vec; List‚Å∫)

import Data.Nat as Nat
open import Data.Nat.Properties
open import Data.Char.Base as Char using (Char)
import Data.Empty as Empty
open import Data.Product using (_√ó_; _,_; proj‚ÇÅ)

open import Data.List.Base as List using (List; []; _‚à∑_)
open import Data.List.Categorical as List
open import Data.List.Sized.Interface
open import Data.List.NonEmpty using (List‚Å∫; _‚à∑_; toList)

open import Data.String as String hiding (toList)
open import Data.Vec as Vec using ()
open import Data.Bool
open import Data.Maybe as Maybe using (nothing; just; maybe‚Ä≤)
open import Data.Maybe.Categorical as MaybeCat
open import Data.Sum
open import Function
open import Category.Monad
open import Category.Monad.State
open import Relation.Nullary
open import Relation.Nullary.Decidable

open import Relation.Unary using (IUniversal; _‚áí_) public
open import Relation.Binary.PropositionalEquality.Decidable public
open import Induction.Nat.Strong hiding (<-lower ; ‚â§-lower) public

open import Data.Subset public
open import Data.Singleton public

open import Text.Parser.Types.Core                public
open import Text.Parser.Types                     public
open import Text.Parser.Position                  public
open import Text.Parser.Combinators               public
open import Text.Parser.Combinators.Char          public
open import Text.Parser.Combinators.Numbers       public
open import Text.Parser.Monad                     public
open import Text.Parser.Monad.Result hiding (map) public

open import Lexer
open import Text.Lexer keywords breaking default hiding (Result) renaming (tokenize to tokenize')

open Agdarsec‚Ä≤ public

-- TODO: lists if present as sub-expressions always have to be parenthesised, which shouldn't be necessary
-- TODO: nested lists are parsed incorrectly when using the alternative "[a,b,c]" list syntax

--------------------------------------
-- Boilerplate

record Tokenizer (A : Set‚â§ l) : Set (level (level‚â§ A)) where
  constructor mkTokenizer
  field tokenize : List.List Char ‚Üí List.List (theSet A)

  fromText : String ‚Üí List.List (theSet A)
  fromText = tokenize ‚àò String.toList

instance
  tokChar : Tokenizer [ Char ]
  tokChar = mkTokenizer id

record RawMonadRun (M : Set l ‚Üí Set l) : Set (Level.suc l) where
  field runM : ‚àÄ {A} ‚Üí M A ‚Üí List.List A
open RawMonadRun public

instance

  Agdarsec‚Ä≤M : RawMonad (Agdarsec {l} ‚ä§ ‚ä•)
  Agdarsec‚Ä≤M  = Agdarsec‚Ä≤.monad

  Agdarsec‚Ä≤M0 : RawMonadZero (Agdarsec {l} ‚ä§ ‚ä•)
  Agdarsec‚Ä≤M0 = Agdarsec‚Ä≤.monadZero

  Agdarsec‚Ä≤M+ : RawMonadPlus (Agdarsec {l} ‚ä§ ‚ä•)
  Agdarsec‚Ä≤M+ = Agdarsec‚Ä≤.monadPlus

  runMaybe : RawMonadRun Maybe.Maybe
  runMaybe = record { runM = maybe‚Ä≤ (_‚à∑ []) [] }

  runList : RawMonadRun List.List
  runList = record { runM = id }

  runResult : {E : Set l} ‚Üí RawMonadRun (Result E)
  runResult = record { runM = result (const []) (const []) (_‚à∑ []) }

  runStateT : ‚àÄ {M A} {{ùïÑ : RawMonadRun M}} ‚Üí RawMonadRun (StateT (Lift ([ Position ] √ób Listb A)) M)
  runStateT {{ùïÑ}} .RawMonadRun.runM =
    List.map proj‚ÇÅ
    ‚àò‚Ä≤ runM ùïÑ
    ‚àò‚Ä≤ (_$ lift (start , []))

  monadMaybe : RawMonad {l} Maybe.Maybe
  monadMaybe = MaybeCat.monad

  plusMaybe : RawMonadPlus {l} Maybe.Maybe
  plusMaybe = MaybeCat.monadPlus

  monadList : RawMonad {l} List.List
  monadList = List.monad

  plusList : RawMonadPlus {l} List.List
  plusList = List.monadPlus

instance
  _ : Tokenizer [ Position √ó Tok ]
  _ = record { tokenize = tokenize' ‚àò fromList }

--------------------------------------
-- Abstract Syntax Tree

infixr 15 _s-‚Üí_
infixr 15 _s-√ó_
infixr 15 _s-‚äé_

infixl 15 _s-+_
infixl 15 _s-$_
infixr 15 _s-,_
infixr 15 _s-‚à∑_
infixl 15 _s-node_

data SType : Set where  -- syntax of type annotations
  s-Nat     : SType
  s-Bool    : SType
  _s-‚Üí_     : SType ‚Üí SType ‚Üí SType
  s-‚ä§       : SType
  s-‚ä•       : SType
  _s-√ó_     : SType ‚Üí SType ‚Üí SType
  _s-‚äé_     : SType ‚Üí SType ‚Üí SType
  s-List    : SType ‚Üí SType
  s-Tree    : SType ‚Üí SType
  s-Stream  : SType ‚Üí SType
  s-Machine : SType

data AST : Set where
  s-true       : AST
  s-false      : AST
  s-ite        : AST ‚Üí AST ‚Üí AST ‚Üí AST
  s-isZero     : AST ‚Üí AST
  _s-+_        : AST ‚Üí AST ‚Üí AST
  s-num        : ‚Ñï ‚Üí AST
  s-Œª          : List String ‚Üí AST ‚Üí AST
  s-var        : String ‚Üí AST
  _s-$_        : AST ‚Üí AST ‚Üí AST

  s-triv       : AST
  _s-,_        : AST ‚Üí AST ‚Üí AST
  s-fst        : AST ‚Üí AST
  s-snd        : AST ‚Üí AST

  s-inl        : AST ‚Üí AST
  s-inr        : AST ‚Üí AST
  s-case       : AST ‚Üí AST ‚Üí AST

  s-nil        : AST
  _s-‚à∑_        : AST ‚Üí AST ‚Üí AST

  s-leaf       : AST ‚Üí AST
  _s-node_     : AST ‚Üí AST ‚Üí AST

  s-ite‚Ñï       : AST ‚Üí AST ‚Üí AST ‚Üí AST
  s-iteList    : AST ‚Üí AST ‚Üí AST ‚Üí AST
  s-iteTree    : AST ‚Üí AST ‚Üí AST ‚Üí AST

  s-head       : AST ‚Üí AST
  s-tail       : AST ‚Üí AST
  s-genStream  : AST ‚Üí AST ‚Üí AST ‚Üí AST

  s-put        : AST ‚Üí AST ‚Üí AST
  s-set        : AST ‚Üí AST
  s-get        : AST ‚Üí AST
  s-genMachine : AST ‚Üí AST ‚Üí AST ‚Üí AST ‚Üí AST

  s-ann        : AST ‚Üí SType ‚Üí AST

--------------------------------------
-- Building parsers with combinators

module ParserM = Agdarsec l [ Position ] ‚ä• (record { into = proj‚ÇÅ })

instance
  _ = ParserM.monadZero
  _ = ParserM.monadPlus
  _ = ParserM.monad

P = ParserM.param [ Token ] (Œª n ‚Üí [ Vec.Vec Token n ]) Œª where (p , _) _ ‚Üí Value (_ , lift (p , []))

p-tok : Tok ‚Üí ‚àÄ[ Parser P [ Token ] ]
p-tok t = maybeTok $ Œª where
  tok@(_ , t') ‚Üí case eq-tok t t' of Œª where
    (yes eq) ‚Üí just tok
    (no ¬¨eq) ‚Üí nothing

p-parens : ‚àÄ {A} ‚Üí ‚àÄ[ ‚ñ° Parser P A ‚áí Parser P A ]
p-parens rec = p-tok t-lpar &> rec <& box (p-tok t-rpar)

p-name : ‚àÄ[ Parser P [ String ] ]
p-name = maybeTok Œª where (_ , t-var s) ‚Üí just s; _ ‚Üí nothing

p-type : ‚àÄ[ Parser P [ SType ] ]
p-type = fix _ $ Œª rec ‚Üí
  let p-nat     = s-Nat     <$ p-tok t-‚Ñï
      p-bool    = s-Bool    <$ p-tok t-ùïÉ
      p-unit    = s-‚ä§       <$ p-tok t-‚ä§
      p-empty   = s-‚ä•       <$ p-tok t-‚ä•
      p-machine = s-Machine <$ p-tok t-Machine
      p-list'   = s-List    <$> (p-tok t-[ &> rec <& box (p-tok t-]))

      p-atom = p-nat <|> p-bool <|> p-unit <|> p-empty <|> p-machine <|> p-list' <|> p-parens rec
      p-√ó    = chainr1 p-atom (box (_s-√ó_ <$ p-tok t-√ó))
      p-+    = chainr1 p-√ó    (box (_s-‚äé_ <$ p-tok t-‚äé))
      p-‚Üí    = chainr1 p-+    (box (_s-‚Üí_ <$ p-tok t-‚Üí))
      -- note: this order of embedding determines the precedence between these operators
      --       the same is true below, e.g., between + and ,

      p-list   = s-List   <$> (p-tok t-List   &> box p-atom)
      p-tree   = s-Tree   <$> (p-tok t-Tree   &> box p-atom)
      p-stream = s-Stream <$> (p-tok t-Stream &> box p-atom)

  in p-‚Üí <|> p-list <|> p-tree <|> p-stream

-- non-recursive nodes
p-true p-false p-num p-var p-triv p-nil : ‚àÄ[ Parser P [ AST ] ]

-- recursive nodes
p-ite p-isZero p-fst p-snd p-inl p-inr p-case p-Œª p-$ p-+ p-,
 p-ite‚Ñï p-iteList p-iteTree p-subexp p-‚à∑ p-list p-leaf p-node
 p-head p-tail p-genStream p-put p-set p-get p-genMachine p-ann : ‚àÄ[ ‚ñ° Parser P [ AST ] ‚áí Parser P [ AST ] ]

p-true  = s-true  <$ p-tok t-true
p-false = s-false <$ p-tok t-false
p-triv  = s-triv  <$ p-tok t-triv
p-nil   = s-nil   <$ p-tok t-nil

p-var = s-var <$> p-name

p-num = let p-‚Ñï : ‚àÄ[ Parser P [ ‚Ñï ] ]
            p-‚Ñï = maybeTok Œª where (_ , t-num n) ‚Üí just n; _ ‚Üí nothing
        in s-num <$> p-‚Ñï

p-ite rec = s-ite
            <$>     (p-tok t-if   &> rec)
            <*> box (p-tok t-then &> rec)
            <*> box (p-tok t-else &> rec)

p-isZero rec = s-isZero <$> (p-tok t-isZero &> rec)
p-fst    rec = s-fst    <$> (p-tok t-fst    &> rec)
p-snd    rec = s-snd    <$> (p-tok t-snd    &> rec)
p-inl    rec = s-inl    <$> (p-tok t-inl    &> rec)
p-inr    rec = s-inr    <$> (p-tok t-inr    &> rec)

p-case rec = s-case <$> (p-tok t-case &> rec)
                    <*> (box (p-tok t-or &> box (p-subexp rec)))

p-Œª rec = (Œª l‚Å∫ ‚Üí s-Œª (toList l‚Å∫)) <$> (p-tok t-Œª &> box (list‚Å∫ p-name) <& box (p-tok t-dot)) <*> rec

p-$ rec = _s-$_ <$> p-subexp rec <*> rec

p-+ rec = chainl1 (p-subexp rec) (box (_s-+_ <$ p-tok t-+))
p-, rec = chainr1 (p-+ rec)      (box (_s-,_ <$ p-tok t-,))
p-‚à∑ rec = chainr1 (p-, rec)      (box (_s-‚à∑_ <$ p-tok t-‚à∑))

p-list rec = (add-nil <$> (p-tok t-[ &> box (chainr1 (p-subexp rec) (box (_s-‚à∑_ <$ p-tok t-,))) <& box (p-tok t-])))
              <|>
              (s-nil <$ p-tok t-[ <& box (p-tok t-])) where
  add-nil : AST ‚Üí AST
  add-nil (l s-‚à∑ r) = l s-‚à∑ (add-nil r)
  add-nil = _s-‚à∑ s-nil

p-leaf rec = s-leaf <$> (p-tok t-< &> rec <& box (p-tok t->))
p-node rec = _s-node_ <$> p-subexp rec
                      <*> box (p-tok t-| &> box (p-subexp rec))

p-ite‚Ñï rec = p-tok t-ite‚Ñï &> box (s-ite‚Ñï <$> p-subexp rec
                                         <*> box (p-subexp rec)
                                         <*> box (p-subexp rec))

p-iteList rec = p-tok t-iteList &> box (s-iteList <$>      p-subexp rec
                                                  <*> box (p-subexp rec)
                                                  <*> box (p-subexp rec))

p-iteTree rec = p-tok t-iteTree &> box (s-iteTree <$>      p-subexp rec
                                                  <*> box (p-subexp rec)
                                                  <*> box (p-subexp rec))

p-head rec = s-head <$> (p-tok t-head &> rec)
p-tail rec = s-tail <$> (p-tok t-tail &> rec)
p-genStream rec = p-tok t-genStream &> box (s-genStream <$>      p-subexp rec
                                                        <*> box (p-subexp rec)
                                                        <*> box (p-subexp rec))

p-put rec = s-put <$> (p-tok t-put &> rec) <*> (box (p-subexp rec))
p-set rec = s-set <$> (p-tok t-set &> rec)
p-get rec = s-get <$> (p-tok t-get &> rec)
p-genMachine rec = p-tok t-genMachine &> box (s-genMachine <$> p-subexp rec
                                                           <*> box (p-subexp rec)
                                                           <*> box (p-subexp rec)
                                                           <*> box (p-subexp rec))

p-ann rec = s-ann <$> p-subexp rec <*> box (p-tok t-: &> box p-type)

p-subexp rec =
  p-true       <|>
  p-false      <|>
  p-num        <|>
  p-var        <|>
  p-triv       <|>
  p-nil        <|>
  p-leaf   rec <|>
  p-parens rec
-- we list here all nullary nodes because they don't need to be
-- guarded by parentheses, so the user can omit them, e.g., in "10 + 20 + 30"
-- same is true for leaf, because it already has a non-empty prefix, e.g., <42>

p-exp = fix _ $ Œª rec ‚Üí
  p-ann        rec <|>
  p-list       rec <|>
  p-node       rec <|>
  p-$          rec <|>
  p-‚à∑          rec <|>
  p-ite        rec <|>
  p-isZero     rec <|>
  p-fst        rec <|>
  p-snd        rec <|>
  p-inl        rec <|>
  p-inr        rec <|>
  p-case       rec <|>
  p-Œª          rec <|>
  p-ite‚Ñï       rec <|>
  p-iteList    rec <|>
  p-iteTree    rec <|>
  p-head       rec <|>
  p-tail       rec <|>
  p-genStream  rec <|>
  p-put        rec <|>
  p-set        rec <|>
  p-get        rec <|>
  p-genMachine rec <|>
  p-subexp     rec

--------------------------------------
-- Parsing

module _ (open Parameters P)
         {{t : Tokenizer (Parameters.Tok P)}}
         {{ùïÑ : RawMonadPlus (M)}}
         {{ùïä : Sized (Parameters.Tok P) Toks}}
         {{ùïÉ : ‚àÄ {n} ‚Üí Subset (theSet (Level.Bounded.Vec (Parameters.Tok P) n)) (theSet (Toks n))}}
         {{‚Ñù : RawMonadRun M}} where

  private module ùïÑ = RawMonadPlus ùïÑ
  private module ùïÉ{n} = Subset (ùïÉ {n})

  parse_by_ : ‚àÄ {A : Set‚â§ l} ‚Üí String ‚Üí ‚àÄ[ Parser P A ] ‚Üí Maybe (theSet A)
  parse s by parser =
   let input = Vec.fromList $ Tokenizer.fromText t s
       parse = runParser parser (n‚â§1+n _) (lift $ ùïÉ.into input)
       check = Œª s ‚Üí if ‚åä Success.size s Nat.‚âü 0 ‚åã
                     then just (Success.value s) else nothing
   in case List.TraversableM.mapM MaybeCat.monad check $ runM ‚Ñù parse of Œª where
        (just (a ‚à∑ _)) ‚Üí just (lower a)
        _              ‚Üí nothing

  parse-exp : String ‚Üí Maybe AST
  parse-exp s = parse s by p-exp

parse : String ‚Üí Maybe AST
parse = parse-exp

--------------------------------------
-- Examples (see: Tests/ for more)

private
  open import Relation.Binary.PropositionalEquality using (_‚â°_; refl)

  _ : parse "if true" ‚â° nothing
  _ = refl

  _ : parse "10 + 20 + 30"   ‚â° just (s-num 10 s-+ s-num 20 s-+ s-num 30)
  _ = refl
  _ : parse "(10 + 20) + 30" ‚â° just ((s-num 10 s-+ s-num 20) s-+ s-num 30)
  _ = refl
  _ : parse "10 + (20 + 30)" ‚â° just (s-num 10 s-+ (s-num 20 s-+ s-num 30))
  _ = refl

  _ : parse "Œª f x. if f x then x else 0" ‚â° just (s-Œª ("f" ‚à∑ "x" ‚à∑ [])
                                                 (s-ite (s-var "f" s-$ s-var "x") (s-var "x") (s-num 0)))
  _ = refl

\chapter{Outline}
\label{ch:outline}

This study expects the reader to have some familiarity with \verb$Î»$-calculus, i.e., it will not go into details about basic concepts like substitution, alpha equivalence or beta reduction.

The reader will also need some expertise with reading code written in functional languages, e.g., Haskell, including concepts like recursion, pattern matching and algebraic data types. Possessing familiarity with dependent types and Agda is an advantage, but not an absolute necessity for following our key points.

First, we discuss the work of others related to our study in Chapter \ref{ch:relatedwork}, where we cite several sources that can assist the reader in understanding our work. Then, from Chapter \ref{sec:lexer} to \ref{sec:typecheck}, we explain our methods of formalising the STLC elaborator. Chapters \ref{sec:algebraic-def} and \ref{sec:normalisation} describe the qutiented well-typed syntax and its standard model evaluation. Chapter \ref{sec:running} presents our high-level functions for running both the elaboration and the evaluation steps, while Chapter \ref{sec:examples} goes through practical examples demonstrating the framework. Finally, in Chapter \ref{ch:conclusion}, we summarise and discuss our results and offer some insights about future work that could improve the implementation.

This thesis, all examples it presents, and the whole codebase is publicly accessible on GitHub \cite{home-repo}.

